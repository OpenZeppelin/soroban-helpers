pub use soroban_rs_macros::soroban;

#[cfg(test)]
pub mod test {
    use stellar_xdr::curr::{ScAddress, ScVal};

    use super::*;
    use crate::{
        self as soroban_rs, Account, ClientContractConfigs,
        mock::{
            account::mock_signer2, mock_account_entry, mock_contract_id, mock_env, mock_signer1,
            mock_simulate_tx_response, mock_transaction_response,
        },
    };

    soroban!(
        r#"
        pub struct Token;
    
        impl Token {
            pub fn __constructor(env: Env, value: u32) {
                env.storage().instance().set(&KEY, &value);
            }
    
            pub fn send(env: &Env, from: Address, to: Address) -> Vec<String> {
                let from_str = from.to_string();
                let to_str = to.to_string();
                vec![&env, from_str, to_str]
            }
        }
    "#
    );

    soroban!(
        r#"
        pub struct Token2;
    
        impl Token2 {
            pub fn __constructor(env: Env, value: u32) {
                env.storage().instance().set(&KEY, &value);
            }
    
            pub fn transfer(env: &Env) -> Vec<String> {
                vec![&env]
            }
        }
    "#
    );

    #[tokio::test]
    async fn test_token_contract() {
        let simulate_transaction_envelope_result = mock_simulate_tx_response(None);

        let signer_1_account_id = mock_signer1().account_id().0.to_string();
        let get_account_result = mock_account_entry(&signer_1_account_id);

        let send_transaction_result = Ok(mock_transaction_response());

        let env = mock_env(
            Some(Ok(get_account_result)),
            Some(Ok(simulate_transaction_envelope_result)),
            Some(send_transaction_result),
        );
        let account = Account::single(mock_signer1());
        let client_configs = ClientContractConfigs {
            contract_id: mock_contract_id(account.clone(), &env),
            env: env.clone(),
            account: account.clone(),
        };

        // uses autogenerated TokenClient
        let mut token_contract = TokenClient::new(&client_configs);

        let alice = ScVal::Address(ScAddress::Account(mock_signer1().account_id()));
        let bob = ScVal::Address(ScAddress::Account(mock_signer2().account_id()));

        let res = token_contract.send(alice, bob).await;
        assert!(res.is_ok());
        assert_eq!(
            res.unwrap().result_meta,
            mock_transaction_response().result_meta
        );
    }

    #[tokio::test]
    async fn test_token_contract_no_inputs() {
        let simulate_transaction_envelope_result = mock_simulate_tx_response(None);

        let signer_1_account_id = mock_signer1().account_id().0.to_string();
        let get_account_result = mock_account_entry(&signer_1_account_id);

        let send_transaction_result = Ok(mock_transaction_response());

        let env = mock_env(
            Some(Ok(get_account_result)),
            Some(Ok(simulate_transaction_envelope_result)),
            Some(send_transaction_result),
        );
        let account = Account::single(mock_signer1());
        let client_configs = ClientContractConfigs {
            contract_id: mock_contract_id(account.clone(), &env),
            env: env.clone(),
            account: account.clone(),
        };

        // uses autogenerated TokenClient
        let mut token_contract = Token2Client::new(&client_configs);

        let res: Result<_, crate::SorobanHelperError> = token_contract.transfer().await;
        assert!(res.is_ok());
        assert_eq!(
            res.unwrap().result_meta,
            mock_transaction_response().result_meta
        );
    }
}
